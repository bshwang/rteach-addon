class OBJECT_OT_execute_linear_motion(bpy.types.Operator):
    bl_idname = "object.execute_linear_motion"
    bl_label  = "Move_L"

    DEBUG_MOVE_L = True

    def execute(self, ctx):

        p = ctx.scene.ik_motion_props
        src, dst = p.goal_object, p.linear_target
        if not (src and dst):
            p.status_text = "Linear source/target not set"
            return {'FINISHED'}

        M_start, M_end = map(np.array, (src.matrix_world, dst.matrix_world))
        steps      = max(1, int(p.linear_frames))
        pos_series = np.linspace(M_start[:3, 3], M_end[:3, 3], steps)

        robot = get_active_robot()
        arm   = bpy.data.objects.get(p.armature)
        if not arm:
            self.report({'ERROR'}, "Armature not found")
            return {'CANCELLED'}

        frame0 = ctx.scene.frame_current
        print(f"[Move_L] Start Frame = {frame0}")

        # ① KUKA + High-Precision LIN 
        if robot == "KUKA" and p.precise_linear and src.get("joint_pose"):
            q_init = np.array(src["joint_pose"], float)
            T_goal = np.linalg.inv(compute_base_matrix(p)) @ \
                     np.array(dst.matrix_world) @ \
                     np.linalg.inv(compute_tcp_offset_matrix(p))
            path = linear_move(q_init, T_goal, p)
            if path is not None:
                for i, q in enumerate(path):
                    ctx.scene.frame_set(frame0 + i)
                    apply_solution(arm, q, frame0 + i, insert_keyframe=True)
                p.status_text = f"Precise LIN done ({len(path)} steps)"
                return {'FINISHED'}

            self.report({'WARNING'}, "Precise LIN failed – fallback to fast mode")

        # ② Fast LIN  
        q_start, q_end = src.matrix_world.to_quaternion(), dst.matrix_world.to_quaternion()
        R_key = R.from_quat([[q_start.x, q_start.y, q_start.z, q_start.w],
                             [q_end.x,   q_end.y,   q_end.z,   q_end.w]])
        slerp = Slerp([0, 1], R_key)

        if robot == "KUKA":
            q3_start = src.get("joint_pose", [0.0]*3)[2]
            q3_end   = dst.get("joint_pose", [0.0]*3)[2]

        ik_solver = get_inverse_kinematics(p)

        master_q = None
        success  = 0

        def stable_ang_diff(a, b):
            return ((a - b + math.pi) % (2 * math.pi)) - math.pi

        pose_index = p.current_index if p.solutions and len(p.solutions) > p.current_index else 0

        for i in range(steps):
            T_goal = np.eye(4)
            T_goal[:3, 3] = pos_series[i]
            t_val = i / (steps - 1) if steps > 1 else 0.0
            T_goal[:3, :3] = slerp([t_val])[0].as_matrix()

            if robot == "KUKA":
                p.fixed_q3 = (1.0 - t_val) * q3_start + t_val * q3_end

            T_flange = (
                np.linalg.inv(compute_base_matrix(p)) @
                T_goal @
                np.linalg.inv(compute_tcp_offset_matrix(p))
            )
            U, _, Vt = np.linalg.svd(T_flange[:3, :3])
            T_flange[:3, :3] = U @ Vt

            sols = ik_solver(T_flange)
            if not sols:
                if self.DEBUG_MOVE_L:
                    print(f"[Move_L] f{frame0+i}: IK failed")
                continue

            print(f"[Move_L] f{frame0+i}: {len(sols)} IK solutions found")

            if i == 0 and "joint_pose" in src:
                q_sel = np.array(src["joint_pose"], float)
                print(f"[Move_L] f{frame0+i}: Applying src joint_pose = {q_sel}")
            elif i == steps - 1 and dst.get("joint_pose"):
                q_sel = np.array(dst["joint_pose"], float)
                print(f"[Move_L] f{frame0+i}: Applying dst joint_pose = {q_sel}")
            elif len(sols) > pose_index:
                q_sel = np.array(sols[pose_index], float)
                print(f"[Move_L] f{frame0+i}: Using pose index {pose_index+1}")
            else:
                if master_q is None:
                    master_q = np.array(sols[0], float)
                def _score(q):
                    q = np.asarray(q)
                    return sum(abs(stable_ang_diff(q[j], master_q[j])) for j in range(len(master_q)))
                q_sel = min(sols, key=_score)
                print(f"[Move_L] f{frame0+i}: Using fallback best match")
            
            master_q = q_sel
            ctx.scene.frame_set(frame0 + i)
            apply_solution(arm, q_sel, frame0 + i, insert_keyframe=True)
            success += 1

        if p.goal_object and master_q is not None:
            fk_func = get_forward_kinematics()
            T_last = (
                compute_base_matrix(p) @
                fk_func(master_q) @
                compute_tcp_offset_matrix(p)
            )
            p.goal_object.matrix_world = Matrix(T_last)

        p.status_text = f"Fast LIN done ({success}/{steps})"
        return {'FINISHED'}
