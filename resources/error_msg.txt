class OBJECT_OT_execute_linear_motion(bpy.types.Operator):
    bl_idname = "object.execute_linear_motion"
    bl_label  = "Move_L"

    DEBUG_MOVE_L = True

    def execute(self, ctx):

        p = ctx.scene.ik_motion_props
        src, dst = p.goal_object, p.linear_target
        if not (src and dst):
            p.status_text = "Linear source/target not set"
            return {'FINISHED'}

        M_start, M_end = map(np.array, (src.matrix_world, dst.matrix_world))
        steps      = max(1, int(p.linear_frames))
        pos_series = np.linspace(M_start[:3, 3], M_end[:3, 3], steps)

        robot      = get_active_robot()
        arm        = bpy.data.objects.get(p.armature)
        if not arm:
            self.report({'ERROR'}, "Armature not found")
            return {'CANCELLED'}

        frame0 = 1  # <-- 하드코딩된 시작 프레임

        if self.DEBUG_MOVE_L:
            print(f"[Move_L] Start Frame = {frame0}")
            print(f"[Move_L] Resetting goal_object to src TCP pose")

        if p.goal_object and "joint_pose" in src:
            fk_func = get_forward_kinematics()
            T_src = (
                compute_base_matrix(p) @
                fk_func(np.array(src["joint_pose"], float)) @
                compute_tcp_offset_matrix(p)
            )
            p.goal_object.matrix_world = Matrix(T_src)

        # ① KUKA + High-Precision LIN 
        if robot == "KUKA" and p.precise_linear and src.get("joint_pose"):
            q_init   = np.array(src["joint_pose"], float)
            T_goal   = np.linalg.inv(compute_base_matrix(p)) @ \
                       np.array(dst.matrix_world) @ \
                       np.linalg.inv(compute_tcp_offset_matrix(p))
                       
            path = linear_move(q_init, T_goal, p)
            if path is not None:
                for i, q in enumerate(path):
                    ctx.scene.frame_set(frame0 + i)
                    apply_solution(arm, q, frame0 + i, insert_keyframe=True)
                p.status_text = f"Precise LIN done ({len(path)} steps)"
                return {'FINISHED'}

            self.report({'WARNING'}, "Precise LIN failed – fallback to fast mode")

        # ② Fast LIN  
        q_start, q_end = src.matrix_world.to_quaternion(), dst.matrix_world.to_quaternion()
        R_key = R.from_quat([[q_start.x, q_start.y, q_start.z, q_start.w],
                             [q_end.x,   q_end.y,   q_end.z,   q_end.w]])
        slerp = Slerp([0, 1], R_key)

        if robot == "KUKA":
            q3_start = src.get("joint_pose", [0.0]*3)[2]
            q3_end   = dst.get("joint_pose", [0.0]*3)[2]

        ik_solver = get_inverse_kinematics(p)

        master_q = None
        success  = 0

        def stable_ang_diff(a, b):
            return ((a - b + math.pi) % (2 * math.pi)) - math.pi

        for i in range(steps):
            T_goal = np.eye(4)
            T_goal[:3, 3] = pos_series[i]
            t_val = i / (steps - 1) if steps > 1 else 0.0
            T_goal[:3, :3] = slerp([t_val])[0].as_matrix()

            if robot == "KUKA":
                p.fixed_q3 = (1.0 - t_val) * q3_start + t_val * q3_end

            T_flange = (
                np.linalg.inv(compute_base_matrix(p)) @
                T_goal @
                np.linalg.inv(compute_tcp_offset_matrix(p))
            )
            U, _, Vt = np.linalg.svd(T_flange[:3, :3])
            T_flange[:3, :3] = U @ Vt

            sols = ik_solver(T_flange)
            if not sols:
                if self.DEBUG_MOVE_L:
                    print(f"[Move_L] f{frame0+i}: IK failed")
                continue

            if i == 0:
                if p.solutions and len(p.solutions) > p.current_index:
                    q_sel = np.array(p.solutions[p.current_index], float)
                    if self.DEBUG_MOVE_L:
                        print(f"[Move_L] f{frame0+i}: Using pose index = {p.current_index + 1}")
                else:
                    q_sel = np.array(sols[0], float)
                    if self.DEBUG_MOVE_L:
                        print(f"[Move_L] f{frame0+i}: Using fallback solution[0]")

                # 디버그: goal pose 출력
                T_debug = (
                    compute_base_matrix(p) @
                    get_forward_kinematics()(q_sel) @
                    compute_tcp_offset_matrix(p)
                )
                pos = T_debug[:3, 3]
                rpy = R.from_matrix(T_debug[:3, :3]).as_euler('xyz', degrees=True)
                print(f"[Move_L] f{frame0+i}: Pose = {np.round(q_sel,4)}")
                print(f"[Move_L] f{frame0+i}: TCP Pos = {np.round(pos*1000,1)} mm, RPY = {np.round(rpy,1)} deg")
            elif i == steps - 1 and dst.get("joint_pose"):
                q_sel = np.array(dst["joint_pose"], float)
                if self.DEBUG_MOVE_L:
                    print(f"[Move_L] f{frame0+i}: Applying dst joint_pose = {np.round(q_sel,4)}")
            else:
                if master_q is None:
                    master_q = np.array(sols[0], float)

                def _score(q):
                    q = np.asarray(q)
                    return sum(abs(stable_ang_diff(q[j], master_q[j]))
                               for j in range(len(master_q)))

                q_sel = min(sols, key=_score)
                if self.DEBUG_MOVE_L:
                    print(f"[Move_L] f{frame0+i}: Using pose index = {sols.index(q_sel)+1}")

            master_q = q_sel
            ctx.scene.frame_set(frame0 + i)
            apply_solution(arm, q_sel, frame0 + i, insert_keyframe=True)
            success += 1

        if p.goal_object and master_q is not None:
            fk_func = get_forward_kinematics()
            T_last = (
                compute_base_matrix(p) @
                fk_func(master_q) @
                compute_tcp_offset_matrix(p)
            )
            p.goal_object.matrix_world = Matrix(T_last)

        p.status_text = f"Fast LIN done ({success}/{steps})"
        return {'FINISHED'}
