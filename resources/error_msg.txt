class OBJECT_OT_teach_pose(bpy.types.Operator):
    bl_idname = "object.teach_pose"
    bl_label = "Teach"

    def execute(self, ctx):
        print("[DEBUG] IK operator started")

        p = ctx.scene.ik_motion_props
        tgt = p.goal_object
        print("[DEBUG] Goal object:", tgt)
        print("[DEBUG] Armature:", p.armature)

        q = tgt.matrix_world.to_quaternion()
        T_goal = np.eye(4)
        T_goal[:3, :3] = R.from_quat([q.x, q.y, q.z, q.w]).as_matrix()
        T_goal[:3, 3] = np.array(tgt.matrix_world.to_translation())

        q_sel, sols = get_best_ik_solution(p, T_goal)
        if not sols:
            p.status_text = "IK failed: no solutions found"
            return {'FINISHED'}

        p.solutions = [list(map(float, s)) for s in sols]
        p.max_solutions = len(sols)

        idx = p.solution_index_ui - 1 if 1 <= p.solution_index_ui <= len(sols) else 0
        if p.use_last_pose:
            idx = p.current_index if 0 <= p.current_index < len(sols) else idx

        if not (0 <= idx < len(sols)):
            p.status_text = f"IK failed: invalid solution index {idx}"
            return {'FINISHED'}

        p.current_index = idx
        p.solution_index_ui = idx + 1
        q_sel = p.solutions[idx]

        frame = ctx.scene.frame_current
        
        success = solve_and_apply(ctx, p, T_goal, frame, insert_keyframe=False)

        if success:
            if p.auto_record:
                bpy.ops.object.record_tcp_point()
            p.status_text = f"Applied 1/{len(sols)}"
        else:
            p.status_text = "IK failed"

        return {'FINISHED'}
